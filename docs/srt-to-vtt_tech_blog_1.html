<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='utf-8'>
  <title>Building a microservice to convert SRT to VTT with HappyScribe API - HappyScribe</title>
  <meta name='description' content='AI-generated page about subtitle conversion.'>
  <meta name='viewport' content='width=device-width,initial-scale=1'>
  <link rel='canonical' href='https://monsiaz.github.io/demo_happyscribe_contents_gen/srt-to-vtt_tech_blog_1.html'>
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css'>
  <link rel='stylesheet' href='settings/web_assets/style.css'>
</head>
<body>
  <header class='topbar'>
     <div class='container topbar-inner'>
        <a class='brand' href='/'><img src='settings/web_assets/header.png' class='hero-img' alt='Header'></a>
     </div>
  </header>

  <main class='container'>
     <nav id='toc' class='toc'></nav>
     <html>
<body>
<h1>Building a microservice to convert SRT to VTT with HappyScribe API</h1>

<p>
Many media teams struggle with maintaining consistent subtitle formats as content swaps between platforms. Converting between SRT and VTT by hand is error prone and adds latency to release cycles. An automated backend that handles this transformation at scale can reduce manual effort and speed up publication.
</p>

<p>
This article walks you through creating a focused microservice that leverages the <strong>HappyScribe API</strong> to ingest an SRT file, orchestrate processing, and produce a VTT file ready for web delivery. We will cover authentication, file upload, polling, transformation, and download in practical steps.
</p>

<h2>Why build a dedicated microservice?</h2>

<p>
Embedding subtitle conversion logic directly into a monolith can create brittle dependencies and complicate scaling. A separate service isolates the workflow and makes it easier to manage retries and rate limits. It also simplifies monitoring and allows independent deployment.
</p>

<p>
By decoupling this feature into a microservice, you can scale subtitle conversion separately from the rest of the application and handle spikes in demand. It also lets you enforce security boundaries and centralize error handling around the subtitle workflow.
</p>

<pre><code class="language-python">
from flask import Flask, request, jsonify
import requests
import os

app = Flask(__name__)
API_KEY = os.getenv('HSS_API_KEY')
BASE_URL = 'https://www.happyscribe.com/api/v1'

@app.route('/convert', methods=['POST'])
def convert_subtitles():
    file_url = request.json.get('file_url')
    if not file_url:
        return jsonify({'error': 'file_url is required'}), 400
    # Steps will follow: upload, transcribe, export
    return jsonify({'status': 'queued'}), 202

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
</code></pre>

<h2>What authentication and throttling apply?</h2>

<p>
Every request to the <strong>HappyScribe API</strong> must include an Authorization header using the <strong>Bearer</strong> scheme. This key is tied to your account and defines rate limits. By default you can make 200 POST /transcriptions requests per hour.
</p>

<p>
On hitting a rate limit, the API returns HTTP 429 with a JSON body containing retry_in_seconds. Your service should catch this, parse the value, and delay retries to avoid hammering the API. Use exponential backoff for 5xx errors as well.
</p>

<pre><code class="language-shell">
curl -X POST "https://www.happyscribe.com/api/v1/transcriptions" \
  -H "Authorization: Bearer $HSS_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "transcription": {
      "name": "subtitle-srt-to-vtt",
      "language": "en-US",
      "tmp_url": "https://cdn.example.com/file.srt",
      "is_subtitle": true,
      "service": "auto"
    }
  }'
</code></pre>

<h2>How to upload media and create transcription?</h2>

<p>
If your SRT file is not public, you can use the uploads endpoint to get a signed URL. Then you perform a PUT to send the file. Finally you call POST /transcriptions and include that signed URL as tmp_url. The API will ingest your subtitle and prepare it for export.
</p>

<pre><code class="language-shell">
# 1. Request a signed URL for upload
SIGNED_URL=$(curl -s -H "Authorization: Bearer $HSS_API_KEY" \
  "https://www.happyscribe.com/api/v1/uploads/new?filename=captions.srt" \
  | jq -r .signedUrl)

# 2. Upload the file to S3
curl -X PUT -T captions.srt "$SIGNED_URL"

# 3. Create transcription from the uploaded SRT
TRANS_ID=$(curl -s -X POST -H "Authorization: Bearer $HSS_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "transcription": {
      "name": "convert-srt",
      "language": "en-US",
      "tmp_url": "'"$SIGNED_URL"'",
      "is_subtitle": true,
      "service": "auto"
    }
  }' https://www.happyscribe.com/api/v1/transcriptions \
  | jq -r .id)
</code></pre>

<h2>How to convert SRT to VTT and download?</h2>

<p>
Once your transcription reaches the <strong>automatic_done</strong> state, you call POST /exports with format set to <strong>vtt</strong>. You can export multiple transcription IDs in one request. Poll the export resource until it is ready, then download the VTT file from download_link.
</p>

<pre><code class="language-shell">
# 4. Poll until transcription is done
while true; do
  STATE=$(curl -s -H "Authorization: Bearer $HSS_API_KEY" \
    https://www.happyscribe.com/api/v1/transcriptions/$TRANS_ID \
    | jq -r .state)
  if [ "$STATE" = "automatic_done" ]; then
    break
  fi
  echo "Waiting for transcription ($STATE)..."
  sleep 5
done

# 5. Request VTT export
EXP_ID=$(curl -s -X POST -H "Authorization: Bearer $HSS_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "export": {
      "format": "vtt",
      "transcription_ids": ["'"$TRANS_ID"'"]
    }
  }' https://www.happyscribe.com/api/v1/exports \
  | jq -r .id)

# 6. Poll until export is ready and download
while true; do
  EXP=$(curl -s -H "Authorization: Bearer $HSS_API_KEY" \
    https://www.happyscribe.com/api/v1/exports/$EXP_ID)
  if [ "$(echo "$EXP" | jq -r .state)" = "ready" ]; then
    curl -L "$(echo "$EXP" | jq -r .download_link)" -o output.vtt
    break
  fi
  sleep 5
done
</code></pre>

<h2>Key takeaways</h2>
<ul>
  <li>Use a separate microservice to isolate subtitle conversion and scale independently.</li>
  <li>Handle <strong>authentication</strong> and rate limits gracefully with exponential backoff.</li>
  <li>Leverage the HappyScribe API to automate <strong>export</strong> of <strong>srt</strong> to <strong>vtt</strong> at scale.</li>
</ul>

<h2>Where to go next?</h2>

<p>
You can extend this base service by adding human review for edge cases, integrating with S3 event triggers, or batching requests for high throughput. Monitoring metrics around latency and failure rates will help maintain reliability.
</p>

<p><em>With this pattern in place you can support any subtitle format conversion reliably and at scale.</em></p>
</body>
</html>
     
  </main>

  <footer>
     <div class='container small text-muted'>© HappyScribe · Generated by <strong>o4-mini-2025-04-16</strong></div>
  </footer>

  <script src='https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js'></script>
  <script>
  document.addEventListener('DOMContentLoaded', () => {
     const toc = document.getElementById('toc');
     if (!toc) return;
     const h2s = Array.from(document.querySelectorAll('main.container h2'));
     if (!h2s.length) { toc.remove(); return; }
     const ul = document.createElement('ul');
     h2s.forEach(h => {
        const id = h.textContent.trim().toLowerCase().replace(/[^a-z0-9]+/g,'-');
        h.id = id;
        const li = document.createElement('li');
        li.innerHTML = "<a href='#"+id+"'>"+h.textContent+"</a>";
        ul.appendChild(li);
     });
     toc.innerHTML = '<h2>Table of contents</h2>';
     toc.appendChild(ul);
  });
  </script>
</body>
</html>