<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='utf-8'>
  <title>Multilingual subtitle pipeline for global releases - HappyScribe</title>
  <meta name='description' content='AI-generated page about subtitle conversion.'>
  <meta name='viewport' content='width=device-width,initial-scale=1'>
  <link rel='canonical' href='https://monsiaz.github.io/demo_happyscribe_contents_gen/srt-to-vtt_tech_use_3.html'>
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css'>
  <link rel='stylesheet' href='settings/web_assets/style.css'>
</head>
<body>
  <header class='topbar'>
     <div class='container topbar-inner'>
        <a class='brand' href='/'><img src='settings/web_assets/header.png' class='hero-img' alt='Header'></a>
     </div>
  </header>

  <main class='container'>
     <nav id='toc' class='toc'></nav>
     { background-color: #f0f4f8; padding: 10px; margin: 20px 0; }
    .accordion-item { border: 1px solid #ddd; margin-bottom: 10px; padding: 10px; }
    .accordion-question { font-weight: bold; margin-bottom: 5px; }
    .accordion-answer { margin-left: 10px; }
  </style>
</head>
<body>

<h2>Multilingual subtitle pipeline for global releases</h2>

<p>
A global media team needs to distribute product launch videos to audiences in Asia, Europe, and South America. They maintain subtitle files in SRT for their primary language but require VTT files for web players in each market.
</p>

<p>
This workflow matters because inconsistent or missing subtitles impact accessibility and viewer retention. Broadcasters and streaming services depend on precise timing, accurate translations, and a repeatable process that scales across dozens of titles each quarter.
</p>

<p>
By automating conversions and translations, teams can reduce manual errors, accelerate release schedules, and serve localized subtitles in formats that integrate directly with modern web players. This ensures global compliance, better SEO, and a uniform viewer experience everywhere.
</p>

<p class="alt-bg">ðŸ”ˆ 69% of users leave a video if subtitles are missing.</p>

<h2>Implementation using the HappyScribe API</h2>

<ol>
  <li>
    Prepare or upload your master SRT file for each source language. If you already have a hosted URL, you can skip the upload step. Otherwise request a signed S3 URL:
    <pre><code>curl -H "Authorization: Bearer $API_KEY" \
  "https://www.happyscribe.com/api/v1/uploads/new?filename=master_en.srt" \
  | jq -r .signedUrl &gt; upload_url.txt</code></pre>
  </li>

  <li>
    PUT your local SRT into the signed URL. This stores the file in HappyScribeâ€™s bucket for ingestion.
    <pre><code>curl -X PUT -T master_en.srt "$(cat upload_url.txt)"</code></pre>
  </li>

  <li>
    Create a transcription entry with the SRT file. Mark it as subtitle input and choose auto alignment. This generates a timeline you can later convert or translate.
    <pre><code>curl -X POST -H "Authorization: Bearer $API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "transcription": {
      "name": "Product_Launch_2025_EN",
      "language": "en-US",
      "tmp_url": "'"$(cat upload_url.txt)"'",
      "is_subtitle": true,
      "service": "alignment"
    }
  }' \
  https://www.happyscribe.com/api/v1/transcriptions</code></pre>
  </li>

  <li>
    Poll the transcription status until it reaches <code>automatic_done</code>. Use exponential back-off to respect rate limits.
    <pre><code>while true; do
  STATE=$(curl -s -H "Authorization: Bearer $API_KEY" \
    https://www.happyscribe.com/api/v1/transcriptions/$TRANS_ID \
    | jq -r .state)
  [ "$STATE" = "automatic_done" ] && break
  sleep 10
done</code></pre>
  </li>

  <li>
    Export the aligned transcript as SRT. This step confirms the timeline and prepares the file for translation or format conversion.
    <pre><code>curl -X POST -H "Authorization: Bearer $API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "export": {
      "format": "srt",
      "transcription_ids": ["'"$TRANS_ID"'"]
    }
  }' \
  https://www.happyscribe.com/api/v1/exports</code></pre>
  </li>

  <li>
    Download the SRT once the export state becomes <code>ready</code>. Store it as your canonical timed text file.
    <pre><code>EXP_ID=abc123
while true; do
  EXP=$(curl -s -H "Authorization: Bearer $API_KEY" \
    https://www.happyscribe.com/api/v1/exports/$EXP_ID)
  [ "$(echo $EXP | jq -r .state)" = "ready" ] && \
    curl -L "$(echo $EXP | jq -r .download_link)" -o Product_Launch_EN.srt && break
  sleep 5
done</code></pre>
  </li>

  <li>
    For each target language, submit a translation order. This example requests Spanish and German machine translation in one batch.
    <pre><code>curl -X POST -H "Authorization: Bearer $API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "order": {
      "source_transcription_id": "'"$TRANS_ID"'",
      "target_languages": ["es-ES","de-DE"],
      "service": "auto",
      "confirm": true
    }
  }' \
  https://www.happyscribe.com/api/v1/orders/translation</code></pre>
  </li>

  <li>
    Poll the translation order until <code>fulfilled</code>. Each target language results in a new transcription ID. Collect all outputs.
    <pre><code>while true; do
  STATUS=$(curl -s -H "Authorization: Bearer $API_KEY" \
    https://www.happyscribe.com/api/v1/orders/$ORDER_ID \
    | jq -r .state)
  [ "$STATUS" = "fulfilled" ] && break
  sleep 30
done</code></pre>
  </li>

  <li>
    Export each translated transcription as VTT. The VTT format integrates seamlessly with HTML5 video players and streaming platforms.
    <pre><code>for T_ID in "${TRANSLATED_IDS[@]}"; do
  curl -X POST -H "Authorization: Bearer $API_KEY" \
    -H "Content-Type: application/json" \
    -d '{
      "export": {
        "format": "vtt",
        "transcription_ids": ["'"$T_ID"'"]
      }
    }
     
  </main>

  <footer>
     <div class='container small text-muted'>Â© HappyScribe Â· Generated by <strong>o4-mini-2025-04-16</strong></div>
  </footer>

  <script src='https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js'></script>
  <script>
  document.addEventListener('DOMContentLoaded', () => {
     const toc = document.getElementById('toc');
     if (!toc) return;
     const h2s = Array.from(document.querySelectorAll('main.container h2'));
     if (!h2s.length) { toc.remove(); return; }
     const ul = document.createElement('ul');
     h2s.forEach(h => {
        const id = h.textContent.trim().toLowerCase().replace(/[^a-z0-9]+/g,'-');
        h.id = id;
        const li = document.createElement('li');
        li.innerHTML = "<a href='#"+id+"'>"+h.textContent+"</a>";
        ul.appendChild(li);
     });
     toc.innerHTML = '<h2>Table of contents</h2>';
     toc.appendChild(ul);
  });
  </script>
</body>
</html>