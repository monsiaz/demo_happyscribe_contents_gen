<!DOCTYPE html><html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'><title>Node.js script for srt to vtt batch processing on server</title><link href='https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css' rel='stylesheet'><link rel='stylesheet' href='../settings/web_assets/style.css'></head><body><header class='topbar'><div class='container topbar-inner'><a class='brand' href='https://www.happyscribe.com'><img src='../settings/web_assets/logo.png' alt='HappyScribe logo'></a><nav class='main-nav'><a href='#'>Tools</a><a href='#'>Resources</a><a href='#'>Pricing</a><a href='#' class='btn-primary'>Start for Free</a></nav></div></header><main class='container'><h2>Why you should convert convert srt to vtt</h2>
<p>Subtitle files are essential for accessibility, SEO, and user engagement. While SRT (SubRip Text) is the most common format for offline playback, VTT (WebVTT) is the de facto standard on the web. Browsers, streaming platforms, and HTML5 video elements all natively support VTT, enabling better styling, cue settings, and integration with JavaScript. If your workflow still relies on SRT, it’s time to modernize by batch converting SRT to VTT on your server.</p>
<p>Whether you deliver human-made subtitles or leverage <a href="#">Automatic transcription</a>, converting to VTT streamlines embedding, styling, and customizing captions in the browser. In this guide, you’ll learn how to build a robust Node.js solution, leverage powerful tools like FFMPEG, and integrate with the HappyScribe <a href="#">API</a> for fully automated pipelines.</p>

<h2>Understanding the differences between SRT and VTT subtitle formats</h2>
<p>SRT and VTT both define start and end times for each caption, but WebVTT adds support for:</p>
<ul>
  <li>Styling cues (bold, italic, underline)</li>
  <li>Positioning and alignment settings</li>
  <li>Regions for multiple subtitle tracks</li>
  <li>Web-friendly UTF-8 encoding without a BOM</li>
</ul>
<p>Converting SRT to VTT is more than just renaming the file extension. The header must include a “WEBVTT” tag, and timecodes require a leading zero on hours. For example:</p>
<pre><code>1
00:00:05,000 --> 00:00:10,000
Hello world.</code></pre>
<p>Becomes:</p>
<pre><code>WEBVTT

1
00:00:05.000 --> 00:00:10.000
Hello world.</code></pre>
<p>Tip: Always validate your VTT files in a browser or with a linter to avoid playback issues.</p>

<h2>Preparing your environment for srt to vtt batch conversion</h2>
<h3>Installing dependencies</h3>
<p>Before writing any code, install Node.js (v14+ recommended) and ensure your server has FFMPEG. You can install FFMPEG on Ubuntu with:</p>
<pre><code>sudo apt update
sudo apt install ffmpeg</code></pre>
<p>Next, scaffold a new project directory and install essential NPM packages:</p>
<pre><code>mkdir subtitle-converter
cd subtitle-converter
npm init -y
npm install fs-extra glob child_process axios</code></pre>
<p>Tip: Use <code>fs-extra</code> for promise-based file operations and <code>glob</code> to match multiple SRT files easily.</p>
<h3>Preparing your directory structure</h3>
<p>Organize your folder as follows:</p>
<ul>
  <li><code>/input</code> – Place all .srt files here</li>
  <li><code>/output</code> – Converted .vtt files will be saved here</li>
  <li><code>convert.js</code> – Your main Node.js script</li>
</ul>
<p>Pitfall to avoid: Mixing relative and absolute paths in scripts. Always resolve file paths with <code>path.resolve</code> to prevent unexpected errors.</p>

<h2>Batch processing with a Node.js script</h2>
<h3>Writing the conversion script</h3>
<pre><code>const fs = require('fs-extra');
const glob = require('glob');
const { exec } = require('child_process');
const path = require('path');

async function convertAllSrt() {
  const files = glob.sync('input/**/*.srt');
  await fs.ensureDir('output');

  for (const file of files) {
    const baseName = path.basename(file, '.srt');
    const outputPath = path.join('output', `${baseName}.vtt`);
    const cmd = `ffmpeg -i "${file}" "${outputPath}" -y`;

    try {
      await execPromise(cmd);
      console.log(\`Converted: \${file} → \${outputPath}\`);
    } catch (err) {
      console.error(\`Error converting \${file}: \`, err);
    }
  }
}

function execPromise(cmd) {
  return new Promise((resolve, reject) => {
    exec(cmd, (error, stdout, stderr) => {
      if (error) return reject(stderr);
      resolve(stdout);
    });
  });
}

convertAllSrt().catch(console.error);</code></pre>
<p>This script uses FFMPEG to handle the actual SRT to VTT conversion. It scans the <code>input</code> folder for all .srt files, processes them in sequence, and writes .vtt files to <code>output</code>.</p>
<h3>Handling errors and logging</h3>
<p>Best practice: separate logs for success and errors. You can append errors to a log file:</p>
<pre><code>fs.appendFileSync('error.log', \`Failed: \${file} - \${err}\\n\`);</code></pre>
<p>This ensures you can review failed conversions without interrupting the rest of the batch process.</p>

<h2>Using FFMPEG for powerful conversions</h2>
<p>FFMPEG is a versatile tool not only for media encoding but also for quick caption conversions. If you need to force UTF-8, you can chain conversions:</p>
<pre><code>ffmpeg -i input.srt temp.utf8.srt -y
ffmpeg -i temp.utf8.srt output.vtt -y</code></pre>
<p>Tip: Some older SRTs use different newline characters. If you encounter malformed files, run:</p>
<pre><code>dos2unix input.srt temp.fix.srt</code></pre>
<p>Pitfall to avoid: Renaming .srt to .vtt without running FFMPEG often causes browsers to reject the file due to missing WEBVTT header.</p>

<h2>Integrating with HappyScribe API for automated workflows</h2>
<h3>Obtaining your API credentials</h3>
<p>Sign up for a HappyScribe account and create an API key in your dashboard. This key allows your server to request conversions, transcriptions, and more. Store your key securely in environment variables:</p>
<pre><code>export HAPPYSCRIBE_API_KEY="your_api_key_here"</code></pre>
<h3>Uploading files and retrieving VTT</h3>
<pre><code>const axios = require('axios');
const fs = require('fs');

async function convertViaHappyScribe(filePath) {
  const form = new FormData();
  form.append('file', fs.createReadStream(filePath));
  form.append('format', 'vtt');
  form.append('mode', 'subtitles');

  const response = await axios.post(
    'https://api.happyscribe.com/v1/transcriptions',
    form,
    {
      headers: {
        'Authorization': \`Bearer \${process.env.HAPPYSCRIBE_API_KEY}\`,
        ...form.getHeaders()
      }
    }
  );

  const jobId = response.data.id;
  console.log('Job created:', jobId);
  // Polling for completion omitted for brevity
}</code></pre>
<p>With this integration, you can combine HappyScribe’s <a href="#">Subtitle editor</a> and <a href="#">Automatic transcription</a> services to deliver polished VTT files. For non-automatic workflows, opt for <em>Human-made subtitles</em> for maximum accuracy.</p>

<h2>Leveraging webvtt-py for Python enthusiasts</h2>
<p>If part of your team prefers Python, the <code>webvtt-py</code> library offers simple commands:</p>
<pre><code>pip install webvtt-py
webvtt convert input.srt -o output.vtt</code></pre>
<p>This approach is ideal for quick scripts or integrating into existing Python-based workflows. Just ensure consistent encoding and test your outputs in multiple browsers.</p>

<h2>Best practices and pitfalls to avoid when converting subtitle files</h2>
<ul>
  <li>Always normalize text encoding to UTF-8 without BOM before conversion.</li>
  <li>Validate timecodes; overlapping cues may break playback.</li>
  <li>Use consistent newline characters (LF) to prevent parsing errors on Linux.</li>
  <li>Log conversions and errors separately for easier debugging.</li>
  <li>Test on multiple devices: desktop browsers, mobile apps, smart TVs.</li>
</ul>
<p>Pitfall: Relying solely on command exit codes can mask failures. Always inspect logs or return values in your script.</p>

<h2>Propel your subtitle workflow with custom tools and services</h2>
<p>Once you have a robust conversion pipeline, consider adding features like:</p>
<ul>
  <li>Dynamic caption styling via CSS and JavaScript.</li>
  <li>Region-based placement for multiple language tracks.</li>
  <li>Real-time caption updates using WebSockets.</li>
  <li>Integration with <a href="#">HappyScribe API</a> for on-demand transcriptions.</li>
</ul>
<p>Combining local tools (FFMPEG, Node.js scripts, webvtt-py) with cloud services (HappyScribe’s Automatic transcription and Human-made subtitles) offers unmatched flexibility. You’ll be able to convert SRT to VTT at scale, maintain high quality, and meet accessibility standards.</p>

<h2>Ready to streamline your subtitle production?</h2>
<p>Start converting SRT to VTT effortlessly with HappyScribe’s suite of tools. Whether you need an API-first approach, an intuitive <a href="#">Subtitle editor</a>, or fully managed Human-made subtitles, HappyScribe has you covered. Sign up today and discover how simple it is to automate your workflows, improve accuracy, and deliver web-optimized captions in minutes.</p>
<p><strong>Get started now with a free trial on HappyScribe and elevate your subtitle workflow.</strong></p><p><a href="convert-srt-to-vtt.html">&larr; Back to converter landing</a></p><h2>More Articles</h2><ul><li><a href="blog_1_how-to-convert-srt-to-vtt-free-using-online-tools.html">How to convert SRT to VTT free using online tools</a></li><li><a href="blog_2_batch-convert-srt-to-vtt-with-python-scripts.html">Batch convert SRT to VTT with Python scripts</a></li><li><a href="blog_3_editing-vtt-styling-after-srt-conversion-in-subtitle-editor.html">Editing VTT styling after SRT conversion in Subtitle editor</a></li><li><a href="blog_4_integrating-srt-to-vtt-conversion-in-adobe-premiere-workflow.html">Integrating SRT to VTT conversion in Adobe Premiere workflows</a></li><li><a href="blog_5_manual-srt-to-vtt-conversion-using-notepad-for-quick-fixes.html">Manual SRT to VTT conversion using Notepad for quick fixes</a></li><li><a href="blog_6_how-to-convert-srt-to-vtt-online-free-with-happyscribe-api.html">How to convert SRT to VTT online free with HappyScribe API</a></li><li><a href="blog_8_comparing-srt-and-vtt-for-live-streaming-caption-workflows.html">Comparing SRT and VTT for live streaming caption workflows</a></li><li><a href="blog_9_automated-subtitle-conversion-using-happyscribe-caption-gene.html">Automated subtitle conversion using HappyScribe Caption generator</a></li><li><a href="blog_10_troubleshooting-common-issues-when-converting-srt-to-vtt.html">Troubleshooting common issues when converting SRT to VTT</a></li></ul></main><footer><div class='container'><p>&copy; HappyScribe</p></div></footer></body></html>